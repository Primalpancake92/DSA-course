Data Structures and Algorithms:

1. Introduction

1.1 What are Data Structures?

A data structure is a selection of ways to storing data, depending on how we would like to store, use, or manipulate the data. They are used primarily to efficiently store large amounts of data, such as accounts stored on the internet. They are the building blocks to creating fast and powerful algorithms.

1.2 What are algorithms?

An algorithm is like a program. It provides the instructions on how to solve a given problem. This is written in programming languages. So writing efficient algorithms are the base to helping us solve problems quicker.

1.3 Data Structures and Algorithms working together

Both of these things work in tandem to solve specific problems by finding suitable ways to store this data, performing operations and manipulations, and then solving problems through them.

2. Arrays

2.1 Introduction to arrays in DSA

An array is a data structure that is used to store many elements and are used by many algorithms. This is something we will delve into, later in the course.

Arrays store data elements, which are indexed (0 to n). For example in Java,

public static void main (String[] args) {
    int[] someNumbers = {0, 1, 2, 3, 4};

    // each of these have indices

    System.out.println(someNumbers[0]); // returns 0
}

2.2 Algorithm Time Complexity

Let's write a simple linear algorithm in python that finds the smallest number in an array.

someNumbers = [3, 15, 7, 2, 5]

min_value = someNumbers[0]
for i in range(len(someNumbers)):
    if someNumbers[i] < min_value:
        min_value = someNumbers[i]

print(min_value) # equating to 2

This algorithm is linear in time complexity. This means that it would search through every single data element in the array to find the lowest value. Now imagine this at scale. If there was a company with millions of users accessing their accounts, would this not significantly slow down the user account access? Hence the importance of algorithms.

2.3 Different time complexities and Big O notation

Time complexity is an abstract concept that is used to assess the time it takes for an operation to complete, especially in the context of DSA. Each algorithm takes time and time complexity gives an insight on the time it takes and nature each algorithm falls under. Here are some of the types of time complexities in DSA:

    - O(1): The fastest out there. It only takes one operation to find what you are looking for. This is
      often in the case of looking at a specific value.
    - O(n): Does n operations for n elements, as it compares one at a time until it finds the max or min.
    - O(n^2): Algorithms like bubble, selection, and insertion sorts belong here. However, they are only good for a data structure that stores a small amount of elements. Larger datasets would cause a quadratic increase in time consumed per operation.
    - O(n log(n)): This is the quickest algorithm time complexity.

2.4 Bubble sort

Bubble sorting is ordering arrays in ascending order. How does it do this?

1. It iterates through the array one value at a time.
2. It compares two values that are adjacent to each other.
3. If current value is higher than the adjacent value, it swaps the value so that the highest value is placed later in the array.
4. This repeats until everything is sorted accordingly.

How to implement?

1. First loop is used to define the number of passes. This determines how many times the program checks the array over and over again.
2. The second loop is the comparator, which compares the two adjacent values. 
3. If current value is higher than the adjacent value, they swap.
4. This is repeated for that pass, and goes on for n-1 passes.

Let's make this in Python and Java:

For Python:

some_array = [7, 3, 9, 12, 11]

n = len(some_array)
for i in range(n-1):
	not_swapped = False
	for j in range(n-i-1):
		if some_array[j] > some_array[j+1]:
			some_array[j], some_array[j+1] = some_array[j+1], some_array[j]
		not_swapped = True
	
	if !(not_swapped):
		break

print(some_array)

For Java:

import java.utils.Arrays;

public class bubbleSort {
	static void bubbleSort(int[] arr) {
		int n = arr.length;
		int temp; // temporarily stores the current value
		boolean swapped;

		for (int i = 0; i < n-1; i++) {
			swapped = false;
			
			for (int j = 0; j < n-i-1; j++) {
				if (arr[j] > arr[j+1]) {
					temp = arr[j];
					a[j] = a[j+1];
					a[j+1] = temp;
					swapped = true;
				}
			}
			if (!swapped) {
				break;	
			}
		}
	}
	
	public static void main(String[] args) {
		int[] someArray = {5, 55, 60, 42, 90, 9};
		System.out.println("Original Array: " + Arrays.toString(someArray));
		
		bubbleSort(someArray);
		
		System.out.println("Bubble sorted array: " + Arrays.toString(someArray));
			
	}
}
