Data Structures and Algorithms:

1. Introduction

1.1 What are Data Structures?

A data structure is a selection of ways to storing data, depending on how we would like to store, use, or manipulate the data. They are used primarily to efficiently store large amounts of data, such as accounts stored on the internet. They are the building blocks to creating fast and powerful algorithms.

1.2 What are algorithms?

An algorithm is like a program. It provides the instructions on how to solve a given problem. This is written in programming languages. So writing efficient algorithms are the base to helping us solve problems quicker.

1.3 Data Structures and Algorithms working together

Both of these things work in tandem to solve specific problems by finding suitable ways to store this data, performing operations and manipulations, and then solving problems through them.

2. Arrays

2.1 Introduction to arrays in DSA

An array is a data structure that is used to store many elements and are used by many algorithms. This is something we will delve into, later in the course.

Arrays store data elements, which are indexed (0 to n). For example in Java,

public static void main (String[] args) {
    int[] someNumbers = {0, 1, 2, 3, 4};

    // each of these have indices

    System.out.println(someNumbers[0]); // returns 0
}

2.2 Algorithm Time Complexity

Let's write a simple linear algorithm in python that finds the smallest number in an array.

someNumbers = [3, 15, 7, 2, 5]

min_value = someNumbers[0]
for i in range(len(someNumbers)):
    if someNumbers[i] < min_value:
        min_value = someNumbers[i]

print(min_value) # equating to 2

This algorithm is linear in time complexity. This means that it would search through every single data element in the array to find the lowest value. Now imagine this at scale. If there was a company with millions of users accessing their accounts, would this not significantly slow down the user account access? Hence the importance of algorithms.

2.3 Different time complexities and Big O notation

Time complexity is an abstract concept that is used to assess the time it takes for an operation to complete, especially in the context of DSA. Each algorithm takes time and time complexity gives an insight on the time it takes and nature each algorithm falls under. Here are some of the types of time complexities in DSA:

    - O(1): The fastest out there. It only takes one operation to find what you are looking for. This is
      often in the case of looking at a specific value.
    - O(n): Does n operations for n elements, as it compares one at a time until it finds the max or min.
    - O(n^2): Algorithms like bubble, selection, and insertion sorts belong here. However, they are only good for a data structure that stores a small amount of elements. Larger datasets would cause a quadratic increase in time consumed per operation.
    - O(n log(n)): This is the quickest algorithm time complexity.

2.4 Bubble sort

Bubble sorting is ordering arrays in ascending order. How does it do this?

1. It iterates through the array one value at a time.
2. It compares two values that are adjacent to each other.
3. If current value is higher than the adjacent value, it swaps the value so that the highest value is placed later in the array.
4. This repeats until everything is sorted accordingly.

How to implement?

1. First loop is used to define the number of passes. This determines how many times the program checks the array over and over again.
2. The second loop is the comparator, which compares the two adjacent values. 
3. If current value is higher than the adjacent value, they swap.
4. This is repeated for that pass, and goes on for n-1 passes.

Let's make this in Python and Java:

For Python:

some_array = [7, 3, 9, 12, 11]

n = len(some_array)
for i in range(n-1):
	not_swapped = False
	for j in range(n-i-1):
		if some_array[j] > some_array[j+1]:
			some_array[j], some_array[j+1] = some_array[j+1], some_array[j]
		not_swapped = True
	
	if !(not_swapped):
		break

print(some_array)

For Java:

import java.utils.Arrays;

public class bubbleSort {
	static void bubbleSort(int[] arr) {
		int n = arr.length;
		int temp; // temporarily stores the current value
		boolean swapped;

		for (int i = 0; i < n-1; i++) {
			swapped = false;
			
			for (int j = 0; j < n-i-1; j++) {
				if (arr[j] > arr[j+1]) {
					temp = arr[j];
					a[j] = a[j+1];
					a[j+1] = temp;
					swapped = true;
				}
			}
			if (!swapped) {
				break;	
			}
		}
	}
	
	public static void main(String[] args) {
		int[] someArray = {5, 55, 60, 42, 90, 9};
		System.out.println("Original Array: " + Arrays.toString(someArray));
		
		bubbleSort(someArray);
		
		System.out.println("Bubble sorted array: " + Arrays.toString(someArray));
			
	}
} 

As an exercise, try to make a bubble sort algorithm that sorts everything in descending order. 

2.5 Selection sort

The selection sort algorithm is similar to the bubble sort in terms of purpose. It can also order
elements in an array from ascending or descending order. However, how it achieves this, and its 
implementation, differ.

How it works:

	1. It runs through n-1 passes (excluding the first pass due to redundancy of the first element).
	2. It establishes the first element as the preconceived lowest value. 
	3. The second iterator checks for any values, apart from the first, being lower than the first 
	   element.
	4. If it is lower, swap the smaller value to the first position due to it being the 'lowest'.
	5. Repeat.

Its implementation:

In python: 

def selection_sort(some_array: list[int]):
	n = len(some_array)
	for i in range(n-1):
		min_index = i
		for j in range(i+1, n):
			if some_array[j] < some_array[min_index]:
				min_index = j
			some_array[i], some_array[min_index] = some_array[min_index], some_array[i]


if __name__ == "__main__":
	arr = [5, 10, 12, 15, 88, 45]
		
	print(arr)
	
	selection_sort(arr)
	
	print(arr)

2.6 Insertion sort

Note that insertion sort is not the same in programmatic semantics and logic, as it does not possess
the active intervention of swapping of array elements. It rather builds the sorted array through an 
approach of building one part of the array to be the sorted part and the other is the to be sorted 
part. The biggest feature is that it assumes the first element of the array is already 'sorted', so
it iterates from 1 to n and does the sorting in this range.

How does it work?	

	1. Take the first value of the unsorted array and performs a check to see if it is ordered.
	2. If not ordered or sorted properly, it moves the value to the sorted array.
	3. In the sorted portion, if not arranged correctly, it would shift it slowly to its right position.
	4. This is repeated for the unsorted portion of the array, until it is completely sorted.

A deep analysis:

The first element is always the 'sorted' part of the array. So the algorithm checks for the second 
value, and sees if it is greater than or less than the first value. If it is not greater than, then
it must be moved to the left and is sorted. The hardest part is understanding how it works programmatically.
We will do the implementation first, then the break it down.

Implementation:

Python: 

some_array = [50, 20, 23, 15, 0, 2, 40]

print("Original array: ", some_array)

n = len(some_array)
for i in range(1, n):
	insert_index = i // stores the insertion marker
	current_element = some_array[i] // current element stored here
	for j in range(i-1, -1, -1): // inside the sorted part 
		if some_array[j] > current_element: 
			some_array[j+1] = some_array[j]
			insert_index = j
		else:
			break
	some_array[insert_index] = current_element

print("Sorted array: ", some_array)

Java:

class Main {
	static void insertionSort(int[] arr) {
		int n = arr.length; 
		int insertIndex;
		int currentElement;	
	
		for (int i = 1; i < n; i++) {
			insertIndex = i;
			currentElement = arr[i];
			for (int j = i - 1; j >= 0; i--) {
				if (arr[j] > currentElement) {
					arr[j+1] = arr[j]
					insertIndex = j;
				} else {
					break;
				}
			}
			arr[insertIndex] = currelElement;
		}
	}
	
	static void main(String[] args) {
		int[] someArray = {90, 70, 50, 30, 10};

		System.out.println("Original array: " + someArray);
		
		System.out.println("Sorted array: " + insertionSort(someArray));
	}	
}
